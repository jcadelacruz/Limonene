<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>Limonene_replit</title>
</head>

  <body style="position: fixed; font-family: 'Lucida Console', 'Courier New','Gill Sans', 'Gill Sans MT', Calibri, 'Trebuchet MS', sans-serif; text-align: left; font-weight: bolder;
    color: darkslategray; background-color: lightslategray;
    " id="body">
    <p style="font-size: 20px; white-space: pre;">
X:<span id="x_coordinate"></span><span id="e1"></span>Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Sem et tortor consequat id porta nibh venenatis. Etiam dignissim diam quis enim. Pellentesque id nibh tortor id. Quis imperdiet massa tincidunt nunc pulvinar sapien et. Nunc faucibus a pellentesque sit amet porttitor.
Y:<span id="y_coordinate"></span><span id="e2"></span>Quis viverra nibh cras pulvinar mattis nunc sed blandit. Velit scelerisque in dictum non consectetur a erat nam. Nibh cras pulvinar mattis nunc sed blandit libero volutpat sed. Nisl pretium fusce id velit ut. Orci ac auctor augue mauris. Dui vivamus arcu felis bibendum ut tristique et. Elit ullamcorper dignissim cras tincidunt lobortis feugiat.
Speed:<span id="speed"></span><span id="e3"></span>Viverra aliquet eget sit amet tellus cras adipiscing enim. Volutpat sed cras ornare arcu. Fringilla ut morbi tincidunt augue interdum. Pulvinar etiam non quam lacus suspendisse faucibus. Quisque egestas diam in arcu. Sed nisi lacus sed viverra tellus.
Angle:<span id="angle"></span><span id="e4"></span>Sit amet consectetur adipiscing elit pellentesque habitant morbi tristique senectus. Et malesuada fames ac turpis egestas maecenas. Vitae suscipit tellus mauris a diam maecenas sed. Magna eget est lorem ipsum dolor sit amet consectetur adipiscing.
    </p>
    <div id="playArea"></div>
    <div id="UI">
      <button id="moveBtnA" class="moveBtn UI">A</button>
      <button id="moveBtnB" class="moveBtn UI">B</button>
      <div id="inventoryDiv" class="UI" style="visibility: hidden;">
      </div>
    </div>
    </body>
<!---------------------------------------------->
  <style>
    html, body{ overscroll-behavior-y: contain;}
    /* Disable text selection for the entire page */
    body {
        user-select: none; -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none;
    }
    /* Enable text selection for specific elements if needed */
    .allow-select {
        user-select: text; -moz-user-select: text; -webkit-user-select: text; -ms-user-select: text;
    }
    #playArea{
      position: absolute;
      top: 0; left: 0;
    }
    .UI, #UI>*{
      z-index: 100;
      position: fixed;
      opacity: 0.7;
    }
  </style>
<!---------------------------------------------->
  <script>
  //WINDOW functions
    
    var FRAMERATE = 24, timer, screenWidth = window.innerWidth, screenHeight = window.innerHeight;
    const UI_ZINDEX = 100, PAUSE_ZINDEX = UI_ZINDEX + 1, BG_ZINDEX = 1, ROOM_ZINDEX = 2; ENTITY_ZINDEX = 5, MSG_ZINDEX = 40;//Play area z index should be below 50 
    window.addEventListener('load', () => {
      document.addEventListener('touchmove', function(event) {if (event.touches.length > 1) { event.preventDefault();}}, { passive: false });// Disable pinch zoom on the document
        //display stuff
      resize(); 
      window.addEventListener('resize', resize);
      window.addEventListener('deviceorientation', resize);
        //update
      startTimer();
        //UI
      initializeJoystickAndFunctions();
      initializeMoveButtons();
        //game instances
      initializeInstances();
      initializePauseBtn();
    });
    //GENERAL functions
    function resize(){
      screenWidth = window.innerWidth; screenHeight = window.innerHeight;
      resizeTo(screenWidth, screenHeight);
    }
    function startTimer(){ timer = setInterval(update, 1000/FRAMERATE);}
    function update(){
        currentRoom.display();
        currentRoom.updatePopulation();
      }

  //GAME INSTANCES
    function initializeInstances(){
      //weapons
      //room
      var r00 = new Room("home", 0,0, roomSize/2,0);
      var r01 = new Room("cross", 0,1, roomSize/2,0);
      var r11 = new Room("kitchen", 1,1, 0,roomSize/2);
      var rn11 = new Room("badlands", -1,1, roomSize,roomSize/2);
      var r02 = new Room("heaven", 0,2, roomSize/2,0);
      roomList = [r00, r01, r11, rn11, r02];
      //entities
      var e01_01 = new Entity(100, 10, 2, 0,2*roomSize/5);
      var e01_02 = new Entity(100, 10, 2, 20,2*roomSize/5);
      var e01_03 = new Entity(100, 10, 2, 30,2*roomSize/5);
      var e01_04 = new Entity(100, 10, 2, 40,2*roomSize/5);
      var e01_11 = new Entity(100, 10, 2, 0,roomSize/5);
      var e01_12 = new Entity(100, 10, 2, 20,roomSize/5);
      var e01_13 = new Entity(100, 10, 2, 30,roomSize/5);
      var e01_14 = new Entity(100, 10, 2, 40,roomSize/5);
      var e01_21 = new Entity(100, 10, 2, 0,3*roomSize/5);
      var e01_22 = new Entity(100, 10, 2, 20,3*roomSize/5);
      var e01_23 = new Entity(100, 10, 2, 30,3*roomSize/5);
      var e01_24 = new Entity(100, 10, 2, 40,3*roomSize/5);
      r01.entityPopulation = [];
        //player
      player = new Player(100, 10, 0, 0,0);
      r00.entityPopulation = [e01_02, e01_03]//, e01_04, e01_011, e01_012, e01_013, e01_014, e01_021, e01_022, e01_023, e01_024];
      r01.entityPopulation = [player, e01_01];
      currentRoom = r01;

      initializeAllPopulationsInRoomList();
      currentRoom.enter();
    }
    function initializePlayer(){}
    function initializeAllPopulationsInRoomList(){
      let l = roomList.length;
      for(let i=0; i<l; i++){
        roomList[i].initializePopulation();
      }
    }

      //WEAPONS
    class Bullet{
      constructor(w, s, sz, dir, x,y){
        this.weapon = w;
        this.speed = s; this.size = sz; this.direction = dir;
        this.sz22 = (this.size/2)*(this.size/2);
        this.x = x; this.y = y;
        
        let d = document.createElement('div');
          d.classList.add("bullet");
          d.style.width = sz+"px";d.style.height = sz+"px";
          d.style.backgroundColor = "white";
          d.style.borderRadius = "65%";
          d.style.rotate = dir+"rad";
          d.style.position = "absolute";
        document.getElementById(currentRoom.name).appendChild(d);
        this.disp = d;
      }
      update(){
        this.move();
        this.executeEffect(this.collides());
        this.display();
      }
      move(){
        let x = this.x + Math.cos(this.direction) * this.speed;
        let y = this.y + Math.sin(this.direction) * this.speed;
        let s = this.size;
        if(x<=0) this.x = 0;
        else if(x+s>=roomSize) this.x = roomSize-s;
        else this.x = x;
        if(y<=0) this.y = 0;
        else if(y+s>=roomSize) this.y = roomSize-s;
        else this.y = y;
      }
      collides(){//pseudocode
        //find closest entity
        let ce = null;
        let shortestDistance = null;
        for(let i=0; i<currentRoom.entityPopulation.length; i++){
          if(currentRoom.entityPopulation[i]===player) continue;
          let x = (currentRoom.entityPopulation[i].x - this.x);
          let y = (currentRoom.entityPopulation[i].y - this.y);
          let distance = (x*x) + (y*y);
          if(distance<shortestDistance || shortestDistance===null){
            shortestDistance = distance;
            ce = currentRoom.entityPopulation[i];
          }
        }
        //see if it collides
        if(shortestDistance!==null){
          if(ce.contains(this.x, this.y)) return ce;
          else if(ce.contains(this.x+ce.size, this.y+ce.size)) return ce;
          else if(ce.contains(this.x+ce.size, this.y)) return ce;
          else if(ce.contains(this.x, this.y+ce.size)) return ce;
        if(this.size>entitySize){
          if(this.contains(ce.x, ce.y)) return ce;
          else if(this.contains(ce.x+entitySize, ce.y+entitySize)) return ce;
          else if(this.contains(ce.x, ce.y+entitySize)) return ce;
          else if(this.contains(ce.x+entitySize, ce.y)) return ce;
        }}
        return -1;
      }
      contains(x, y){//assuming bullet is a circle
        let x2 = (x-(this.x+(this.size/2)))*(x-(this.x+(this.size/2))), y2 = (y-(this.y+(this.size/2)))*(y-(this.y+(this.size/2)));
        if((this.sz22)>(x2+y2)) return true;
        else return false;
      }
      executeEffect(e){
        if(e===-1) return;
        e.attack(this.weapon.damage);
        console.log(this.weapon.name + " hit " + e.name);
      }
      display(){
        this.disp.style.left = this.x + "px";
        this.disp.style.bottom = this.y + "px";
      }
    }
    class Weapon{
      constructor(n,  bS,r,bSz,s,   bC,rD,mS,   d, m,   k,   sK,w){
        this.name = n;
        this.bulletSpeed = bS; this.range = r; this.bulletSize = bSz, this.spread = s;//bullet movement identity
        this.bulletCount = bC; this.reloadDuration = rD; this.magSize = mS;//bullet use identity
        this.damage = d; this.magicEffect = m; this.knockback = k;//victim effects
        this.shooterKnockback = sK; this.weight = w;//shooter effects (active vs passive)

        this.bullets = [];
      }
      executeWeaponFunction(e){
        let aimDir = e.moveAngle;
        for(let i = 0; i < this.bulletCount; i++){
          let es2 = (entitySize - this.bulletSize)/2;
          let b = new Bullet(this, this.bulletSpeed, this.bulletSize, aimDir, e.x+(es2), e.y+(es2));
          this.bullets.push(b);
          aimDir += this.spread;
        }
      }
      unequip(){
        for(let i = 0; i < this.bullets.length; i++){
          this.bullets[i].disp.remove();
        }
        this.bullets = [];
      }
      update(){
        for(let i = 0; i < this.bullets.length; i++){
          this.bullets[i].update();
        }
      }
    }
      //ROOM
    var roomList = [], currentRoom;
    const roomSize = 500;
    class Room{
      constructor(n, x, y, ex, ey){
        this.name = n;
        this.entityPopulation = [];
        this.exitX = ex; this.exitY = ey;
        this.x = x; this.y = y;
      }
      updatePopulation(){
        let l = this.entityPopulation.length;
        let r = currentRoom;
        for(let i = 0; i < l; i++){
          //try{
            this.entityPopulation[i].update();
            this.entityPopulation[i].display();
          //}
          //catch(err){}
        }
      }
      initializePopulation(){
        let l = this.entityPopulation.length;
        for(let i = 0; i < l; i++){
          this.entityPopulation[i].inGame = true;
        }
      }
      initializeDisplay(){
        if(document.getElementById(this.name)!=null) return;
        let room = document.createElement('div');
        room.id = this.name;
        room.classList.add("room");
        room.style.width = roomSize + "px";
        room.style.height = roomSize + "px";
        room.style.position = "relative";
        room.style.backgroundColor = "royalblue";
        room.style.zIndex = ROOM_ZINDEX;
        let p = document.createElement('p');
        p.innerText = this.name;
        room.appendChild(p);
        document.getElementById('playArea').appendChild(room);

        let l = this.entityPopulation.length;
        for(let i = 0; i < l; i++){
          this.entityPopulation[i].initializeDisplay();
        }
      }
      display(){
        let c = document.getElementById(this.name);
        c.style.left = (screenWidth/2)-player.x +"px";
        c.style.top = (screenHeight/2)+player.y-roomSize +"px";
      }
      enter(){
        currentRoom = this;
        this.initializeDisplay();
      }
      entityTransfersTo(r, e){
        console.log("transfering to "+r.x+","+r.y);
        let originalArray = this.entityPopulation, newArray = r.entityPopulation;
        let indexToRemove = originalArray.indexOf(e);

        if (indexToRemove !== -1) {
            // Remove the element from the original array and add it to the new array
            newArray.push(originalArray.splice(indexToRemove, 1)[0]);

            console.log("Original Array:", originalArray);
            console.log("New Array:", newArray);
        } else {
            console.log("Element not found in the original array");
        }

        //remove display
        document.getElementById(currentRoom.name).removeChild(e.disp);
      }
      leave(){
        document.getElementById('playArea').removeChild(document.getElementById(this.name));
      }
    }
    function getRoom(x,y){
      let l = roomList.length;
      for(let i = 0; i<l; i++){
        if(roomList[i].x == x && roomList[i].y == y) return roomList[i];
      }
      return -1;
    }
      //ENTITY
    var player;
    const sightRange = 150, sightRangeSquared = sightRange*sightRange, attackRange = 30, attackRangeSquared = attackRange*attackRange, entitySize = 50;
    class Entity{
      constructor(h, s, sp, x, y){
        //attack
        this.maxHP = h;
        this.hp = h;
        this.str = s;
        //position
        this.speed = sp;
        this.inGame = false;
        this.x = x; this.y = y;
        this.moveAngle = 0;
        this.trackingPlayer = true;
        //display
        this.disp = null;
      }
      move(){
        let x = this.x + Math.cos(this.moveAngle) * this.speed;
        let y = this.y + Math.sin(this.moveAngle) * this.speed;
        if(x<=0) this.x = 0;
        else if(x+entitySize>=roomSize) this.x = roomSize-entitySize;
        else this.x = x;
        if(y<=0) this.y = 0;
        else if(y+entitySize>=roomSize) this.y = roomSize-entitySize;
        else this.y = y;
      }
      update(turn){
        //pathfinding
        let px = player.x - this.x; let py = player.y - this.y;
        let d = (px*px)+(py*py);
        if( d<=sightRangeSquared){//checking if entity is near the player
          let m = Math.atan(py/px);
          this.moveAngle = (px<0) ? ((py<0)?m+Math.PI:Math.PI+m) : ((py<0)?(2*Math.PI)+m:m);
          this.trackingPlayer = true;
          if(d<=attackRangeSquared){
            this.attackPlayer();
            return;//to give player space ig?
          }
        }
        else{//case; not near player
          //if(this.trackingPlayer===true){
            px = currentRoom.exitX - this.x - entitySize/2; py = currentRoom.exitY - this.y - entitySize/2;
            let m = Math.atan(py/px);
            this.moveAngle = (px<0) ? ((py<0)?m+Math.PI:Math.PI+m) : ((py<0)?(2*Math.PI)+m:m);
            this.trackingPlayer = false;
          //}
          //check if near exit of room
          if(this.contains(currentRoom.exitX, currentRoom.exitY)){ this.transferRooms();}
        }
        //movement
        this.move();
      }
      findRoomAtDirection(){
        let dir = (currentRoom.exitX!==roomSize/2) ? ((currentRoom.exitX===0)? "left" : "right") : ((currentRoom.exitY===0)? "down" : "up" );
        let r = currentRoom;
        switch(dir){
          case "left":
            r = getRoom(currentRoom.x-1, currentRoom.y);
            if(r===-1)break;
            console.log("going left");
            this.x = roomSize-entitySize-1; this.y = roomSize/2;
            break;
          case "right":
            r = getRoom(currentRoom.x+1, currentRoom.y);
            if(r===-1)break;
            console.log("going right");
            this.x = 1; this.y = roomSize/2;
            break;
          case "down":
            r = getRoom(currentRoom.x, currentRoom.y-1);
            if(r===-1)break;
            console.log("going down: "+currentRoom.x+","+currentRoom.y);
            this.x = roomSize/2; this.y = roomSize-entitySize-1;
            break;
          case "up":
            r = getRoom(currentRoom.x, currentRoom.y+1);
            if(r===-1)break;
console.log("going up");
            this.x = roomSize/2; this.y = 1;
            break;
        }
        return r;
      }
      transferRooms(){
        let r = this.findRoomAtDirection();
        if(r!==-1)currentRoom.entityTransfersTo(r, this);
      }
      contains(x, y){//assuming entity is a box
        let m = 8;//margin of error
        if( (this.x-m<x && x<this.x+m+entitySize) && (this.y-m<y && y<this.y+m+entitySize) ) return true;
      }
      display(){
       // console.log("entity: "+this.hp+"/"+this.maxHP+" at ("+this.x+","+this.y+")");
        this.disp.style.left = this.x + "px";
        this.disp.style.bottom = this.y + "px";
      }
      initializeDisplay(){
        let en = document.createElement('div');
        en.classList.add("entity");
        en.style.width = entitySize + "px"; en.style.height = entitySize + "px";
        en.style.left = this.x + "px"; en.style.bottom = this.y + "px";
        en.style.backgroundColor = "darkviolet";//TEMP BACKGROUND COLOR
        en.style.zIndex= ENTITY_ZINDEX;
        en.style.position= "absolute";
        document.getElementById(currentRoom.name).appendChild(en);
        this.disp = en;
      }
      attackPlayer(){
        
      }
      attack(damage){
        this.hp-=damage;
        if(this.hp===0){
          this.hp = 0;
          this.performDeath();
        }
        if(this.hp>this.maxHP) this.hp = this.maxHP;
      }
      performDeath(){
        currentRoom.entityTransfersTo(new Room("dead", 100,100,0,0), this);
      }
    }
    class Player extends Entity{
      constructor(h, s, sp, x, y){
        super(h, s, sp, x, y);
        this.inventory = [new Weapon("pistol",  20,100,5  ,0.2 ,   1 ,10,1 ,   1,null,20,   10,0.08), new Weapon("sword" ,  30,140,110,0.78,  3 ,10,1 ,  1 ,null,16,  3 ,0.2 ), new Weapon("musket",  25,80 ,7  ,0.4 ,  5 ,99,5 ,  4 ,null,13,  14,0.25)];
      }
      update(){
        //check if near exit of room
        let gap = 5;
        if(this.contains(0,roomSize/2)){
          if(this.transferRoomsTo(-1,0)===1)//left
          {this.x = roomSize-entitySize-gap; this.y = roomSize/2;}
        }
        else if(this.contains(roomSize,roomSize/2)){
          if(this.transferRoomsTo(1,0)===1)//right
          {this.x = gap; this.y = roomSize/2;}
        }
        else if(this.contains(roomSize/2,0)){
          if(this.transferRoomsTo(0,-1)===1)//down
          {this.x = roomSize/2; this.y = roomSize-entitySize-gap;}
        }
        else if(this.contains(roomSize/2,roomSize)){
          if(this.transferRoomsTo(0,1)===1)//up
          {this.x = roomSize/2; this.y = gap;}
        }
        //move
        this.move();
        //weapons
        this.updateEquippedWeapons();
      }
      transferRoomsTo(xAdd, yAdd){
        let r = getRoom(currentRoom.x+xAdd, currentRoom.y+yAdd);
        //let r = this.findRoomAtDirection();
        if(r!==-1){
          currentRoom.entityTransfersTo(r, this);
          currentRoom.leave();
          r.enter();
          return 1;
        }
        else return -1;
      }
      contains(x, y){
        let m = 2;//margin of error
        if( (this.x-m<x && x<this.x+m+entitySize) && (this.y-m<y && y<this.y+m+entitySize) ) return true;
      }
      initializeDisplay(){
        let en = document.createElement('div');
        en.classList.add("entity");
        en.style.width = entitySize + "px";
        en.style.height = entitySize + "px";
        en.style.left = this.x + "px";
        en.style.bottom = this.y + "px";
        en.style.backgroundColor = "red";//TEMP BACKGROUND COLOR
        en.style.zIndex = ENTITY_ZINDEX;
        en.style.position = "absolute";
        document.getElementById(currentRoom.name).appendChild(en);
        this.disp = en;
      }
      updateEquippedWeapons(){
        let weapons = [moveBtnA.weapon, moveBtnB.weapon];
        for(let i = 0; i<weapons.length; i++){
          if(weapons[i]!==null) weapons[i].update();
        }
      }
    }

  //PAUSE BUTTON functions
    var pauseBtn, pauseDiv = document.createElement('div'), paused = false;
    const uiTBSize = 100;
    function initializePauseBtn(){
      pauseBtn = new PauseBtn(pauseDiv);
      inventoryBtn = new InventoryBtn("inventory","yellow", document.createElement('div'), "palegoldenrod");
      let settingsDiv = document.createElement('div');
      settingsBtn = new UITransportBtn("settings","lightgreen", settingsDiv, "green");
      storeBtn = new UITransportBtn("store","gray", document.createElement('div'), "slategray");
      quitBtn = new UITransportBtn("quit","palevioletred", document.createElement('div'), "pink");
    }
    class UITransportBtn{
      constructor(n,c,  d,dc){
        this.name = n;
        //function binding
        this.myOpenDiv = this.openDiv.bind(this);
        this.myCloseDiv = this.closeDiv.bind(this);
        //div element
        d.id = n;
        d.style = "width: 100%; height: 100%; opacity: 95%; position: fixed; top: 0; left: 0; visibility: hidden; background-color: "+dc+"; z-index: "+(PAUSE_ZINDEX-1)+";";
          //appending
        this.divElement = d;
        document.getElementById('body').appendChild(d);
        this.initializeContents();
        //htmlElement button
        let h = document.createElement('button');
        h.style = "background-color: "+c+"; width: "+uiTBSize+"px; height: "+uiTBSize+"px; opacity: 90%; margin: 30px; z-index: "+(PAUSE_ZINDEX-1)+"; display: flex; justify-content: center; align-items: center;font-family: inherit;";
        let l = document.createElement('p'); l.innerText = this.name;
        l.style = "color: black; font-family: inherit; font-weight: bolder;";
        h.appendChild(l);
          //function
        h.addEventListener('click', this.myOpenDiv);
          //appending
        this.htmlElement = h;
        pauseBtn.divElement.appendChild(this.htmlElement)
      }
      openDiv(){
        //close and open respective divs
        pauseBtn.divElement.style.visibility = "hidden";
        this.divElement.style.visibility = 'visible';
        //pauseBtn function replacement
        pauseBtn.htmlElement.innerText = "back";
        pauseBtn.replaceFunction(this);
      }
      closeDiv(){
        this.divElement.style.visibility = 'hidden';
        pauseBtn.divElement.style.visibility = 'visible';
      }
      initializeContents(){}
    }
    const invBtnSize = 60, invBtnMarginSize = 10, invBtnSizeH = 60;
    var selectedWeaponIndex = null;
    class InventoryBtn extends UITransportBtn{
      openDiv(){
        //close and open respective divs
        pauseBtn.divElement.style.visibility = "hidden";
        this.divElement.style.visibility = 'visible';
        //pauseBtn function replacement
        pauseBtn.htmlElement.innerText = "back";
        pauseBtn.replaceFunction(this);
        this.updateInventoryDiv();
      }
      initializeContents(){
        //styling the div
        let i = document.createElement('div'); i.id = "inventoryPortion";
        i.style = "width: 100%; height: 100%; flex-direction: column; align-items: flex-start; justify-content: flex-start;";
        this.divElement.appendChild(i);
        //display the inventory
        this.setColumns();
      }
      setColumns(){
        let i = document.getElementById('inventoryPortion');
        i.innerText = "";
        let latestRow, cols = Math.floor((screenWidth-100)/(invBtnSize+(invBtnMarginSize*2)));
        for(let j=0; j<player.inventory.length; j++){
          //make row
          if(j%cols===0){
            latestRow = document.createElement('div'); latestRow.id = "row"+(j+1);
            latestRow.style = "display: flex; flex-direction: row; align-items: flex-start; justify-content: flex-start;";
            i.appendChild(latestRow);
          }
          //make item element
          let w = document.createElement('div'); w.id = player.inventory[j].name;
          let a = document.createElement('p'); a.id = player.inventory[j].name + "ID";
          a.style.margin = "0";
          w.appendChild(a);
          let p = document.createElement('p'); p.id = player.inventory[j].name + "Label";
          p.innerText = player.inventory[j].name;
          p.style.margin = "0";
          w.appendChild(p);
          w.style = "width: "+invBtnSize+"px; height: "+invBtnSizeH+"px; background-color: rgba(10, 10, 10, 0.9); color: white; font-size: 14px; font-weight: regular; font-family: inherit; margin: "+invBtnMarginSize+"px; display: flex; flex-direction: column; align-items: center; justify-content: center;";
            //function
          w.addEventListener('click', this.clickItemElement);
          latestRow.appendChild(w);
        }
      }
      clickItemElement(){
        let selectedText = "[THIS]", equippedText = "BTN", prevSelectedWeaponIndex = selectedWeaponIndex;
        //find weapon index in inventory
        for(let i=0; i<player.inventory.length; i++){
          if(player.inventory[i].name === this.id) selectedWeaponIndex = i;  
        }
        if(selectedWeaponIndex===null) console.log("error in clickItemElement()");
          //if something else was selected
        if(selectedWeaponIndex!==prevSelectedWeaponIndex&&prevSelectedWeaponIndex!==null){
          let itid = document.getElementById(player.inventory[prevSelectedWeaponIndex].name + "ID");//unselect
          itid.innerText = "";
        }
        
        //IDENTIFY STATE
        let it = document.getElementById(player.inventory[selectedWeaponIndex].name + "ID");
        if(it.innerText.substring(0,1)==="["){
//console.log("has [");

          if(it.innerText.substring(0, selectedText.length)===selectedText){//IF SELECTED
            //console.log("selected");
            if(moveBtnA.weapon===null || moveBtnB.weapon!==null){
              //console.log("equipping to A");
              if(moveBtnA.weapon!==null){
                let ib = document.getElementById(moveBtnA.weapon.name + "ID");
                ib.innerText = "";
                moveBtnA.unequipWeapon();
              }
              moveBtnA.setWeapon(player.inventory[selectedWeaponIndex]);
              it.innerText = "["+equippedText+"A]";
            }else if(moveBtnB.weapon===null){
              //console.log("equipping to B");
              moveBtnB.setWeapon(player.inventory[selectedWeaponIndex]);
              it.innerText = "["+equippedText+"B]";
            }
            selectedWeaponIndex = null;
          }else if(it.innerText.substring(1,equippedText.length+1)===equippedText){//if equipped at all
            //console.log("equipped");
            
            if(it.innerText.substring(equippedText.length+1,equippedText.length+2)==="A"){//IF EQUIPPED BY BTNA
              moveBtnA.unequipWeapon();
            
            }else if(it.innerText.substring(equippedText.length+1,equippedText.length+2)==="B"){//IF EQUIPPED BY BTNB
              moveBtnB.unequipWeapon();
            }
            it.innerText = "";//unselect
          }

          
        }else{//UNSELECTED
          //console.log("unselected");
          //make it selected
          it.innerText = selectedText;
        }
      }
      updateInventoryDiv(){
        let indexA = null, indexB = null;
        this.setColumns();
        if(moveBtnA.weapon!==null){
          indexA = player.inventory.indexOf(moveBtnA.weapon);
          console.log(document.getElementById(player.inventory[indexA].name+"ID"));
          document.getElementById(player.inventory[indexA].name+"ID").innerText = "[BTNA]";
        }
        if(moveBtnB.weapon!==null){
          indexB = player.inventory.indexOf(moveBtnB.weapon);
          document.getElementById(player.inventory[indexB].name+"ID").innerText = "[BTNB]";
        }
      }
    }
    class PauseBtn{
      constructor(d){//assume that pauseDiv is already created
        pauseBtn = this;
        //function binding
        this.myPauseFunction = this.pauseFunction.bind(this);
        this.specialPauseFunction = this.joystickPauseFunction.bind(this);
        this.myCloseOpenedUIBtn = this.closeOpenedUIBtn.bind(this);
        //make htmlElement
        this.name = "pause";
        let h = document.createElement('button'); h.id = "pauseBtn";
        let size = 62;
        h.style = "width: "+size+"px; height: "+size+"px; border-color: black; border-width: 4px; margin: 20px; border-radius: 10%; background-color: lightgreen; position: fixed; top: 0; right: 0; z-index: "+PAUSE_ZINDEX+";";
          //functions
        h.addEventListener('click', this.myPauseFunction);
        //h.addEventListener('mousedown' , this.myPauseFunction);
        this.openedUIBtn = null;
        
        this.htmlElement = h;
        document.getElementById('UI').appendChild(this.htmlElement);
        //div element
        d = document.createElement('div'); d.id = "pauseDiv";
        d.style = "width: 100%; height: 100%; opacity: 50%; position: fixed; top: 0; left: 0; display: flex; justify-content: center; align-items: center; background-color: black; z-index: "+(PAUSE_ZINDEX-1)+";";
        d.style.visibility = "hidden";
        document.getElementById('body').appendChild(d);
        this.divElement = d;
      }
      pauseFunction(){
        if(!paused){
          clearInterval(timer);
          //make all pause elements visible
          this.divElement.style.visibility = "visible";
          //make pauseBtn to pauseFunction
          paused = true;

          //joystick shenanigans
          try{pauseBtn.htmlElement.removeEventListener('touchstart', pauseBtn.specialPauseFunction);}
          catch(err){}
        }
        else{
          //remove all elements visibility
          this.divElement.style.visibility = "hidden";
          //re set pause btn
          paused = false;
          //timer start
          startTimer();
        }
      }
      joystickPauseFunction(){
        this.pauseFunction();
        joystick.stopJoystick();
        try{pauseBtn.htmlElement.removeEventListener('touchstart', pauseBtn.specialPauseFunction);}
        catch(err){}
      }
      replaceFunction(uitb){
        this.openedUIBtn = uitb;
        this.htmlElement.removeEventListener('click', this.myPauseFunction);
        setTimeout(() => {
          if(this.openedUIBtn!==null)this.htmlElement.addEventListener('click', this.myCloseOpenedUIBtn);
        }, 10);
      }
      closeOpenedUIBtn(){
        this.openedUIBtn.closeDiv();
        this.openedUIBtn = null;
        this.htmlElement.innerText = "";
        this.htmlElement.removeEventListener('click', this.myCloseOpenedUIBtn);
        setTimeout(() => {
          if(this.openedUIBtn===null)this.htmlElement.addEventListener('click', this.myPauseFunction);
        }, 10);
      }
    }
  //MOVE BUTTON functions
    var moveBtnA, moveBtnB;
    function initializeMoveButtons(){
      moveBtnA = new MoveBtn(document.getElementById('moveBtnA'), "yellow", 0,100);
      moveBtnB = new MoveBtn(document.getElementById('moveBtnB'), "blue", 100,0);
      //moveBtnB.setWeapon(new Weapon(1,2,3,4,5,6,7,8,9));//test
    }
    class MoveBtn{
      constructor(buttonElement, color, b,r){
        //binds
        this.myExecuteWeaponFunction = this.executeWeaponFunction.bind(this);
        this.myUnequippedWeaponFunction = this.unequippedWeaponFunction.bind(this);
        //htmlElement
        this.htmlElement = buttonElement;
        this.htmlElement.addEventListener('touchstart', this.myUnequippedWeaponFunction);
        this.htmlElement.addEventListener('mousedown' , this.myUnequippedWeaponFunction);
        this.color = color;
        let size = 100;
        this.htmlElement.style = "background-color: "+color+"; width: "+size+"px; height: "+size+"px; border-radius: 100%; margin: 10px; bottom: "+b+"px; right: "+r+"px;";

        this.weapon = null;
      }
      setWeapon(weapon){
        if(this.weapon!==null){
          this.weapon.unequip();
          this.htmlElement.removeEventListener('touchstart', this.myExecuteWeaponFunction);
          this.htmlElement.removeEventListener('mousedown' , this.myExecuteWeaponFunction);
        }
        else{
          this.htmlElement.removeEventListener('touchstart', this.myUnequippedWeaponFunction);
          this.htmlElement.removeEventListener('mousedown' , this.myUnequippedWeaponFunction);
        }
        this.weapon = weapon;
        this.htmlElement.addEventListener('touchstart', this.myExecuteWeaponFunction);
        this.htmlElement.addEventListener('mousedown' , this.myExecuteWeaponFunction);
      }
      unequipWeapon(){
        this.weapon.unequip();
        this.htmlElement.removeEventListener('touchstart', this.myExecuteWeaponFunction);
        this.htmlElement.removeEventListener('mousedown' , this.myExecuteWeaponFunction);
        this.htmlElement.addEventListener('touchstart', this.myUnequippedWeaponFunction);
        this.htmlElement.addEventListener('mousedown' , this.myUnequippedWeaponFunction);
        this.weapon = null;
      }
      unequippedWeaponFunction(){
        console.log("button has no equipped weapon");
      }
      executeWeaponFunction(){
        this.weapon.executeWeaponFunction(player);
      }
    }
    /*function kob(){
      document.getElementById("body").style.backgroundColor = "blue";
    }
    function bok(){
      document.getElementById("body").style.backgroundColor = "yellow";
    }

    function btnAFunction(){
      document.getElementById("body").style.backgroundColor = "blue";
    }
    function btnBFunction(){
      document.getElementById("body").style.backgroundColor = "orange";
    }*/
  //JOYSTICK functions
    var joystick;
    const INITIALRADIUS = 60, INITIALMARGIN = 40;
    function initializeJoystickAndFunctions(){
      //making joystick + css
      joystick = new Joystick();
      joystick.displayStats();
    }
    class Joystick{
      constructor(){
        //values
        this.radius = INITIALRADIUS;
        this.posX = 0; this.posY = 0;
        this.spd = 0; this.angl = 0;
        //binding functions
        this.myMoveJoystick = this.moveJoystick.bind(this);
        this.myStartJoystick = this.startJoystick.bind(this);
        this.myStopJoystick = this.stopJoystick.bind(this);
        //htmlElement
        let h = document.createElement('div'); h.id = 'joystick';
        h.style = "background-color: red; margin: "+INITIALMARGIN+"px; border-radius: 100%; bottom: 0; left: 0;";
        h.style.width = this.radius*2+"px"; h.style.height = this.radius*2+"px";
          //mouse controls
        h.addEventListener('mousedown', this.myStartJoystick);
        window.addEventListener('mouseup', this.myStopJoystick);
        window.addEventListener('mouseleave', this.stopJoystick);
        window.addEventListener('mousemove', this.myMoveJoystick);
          //touch controls
        h.addEventListener('touchstart', this.myStartJoystick);
        h.addEventListener('touchend', this.myStopJoystick);
          //joystick.addEventListener('touchcancel', myStopJoystick);
        document.getElementById('body').addEventListener('touchmove', this.myMoveJoystick);
          //TEST display buttons
        document.getElementById("x_coordinate").innerText = 0;
        document.getElementById("y_coordinate").innerText = 0;
        document.getElementById("speed").innerText = 0;
        document.getElementById("angle").innerText = 0;
          //append
        this.htmlElement = h;
        document.getElementById('UI').appendChild(this.htmlElement);
        this.joystickClicked = false;
        //joystickMovable
        this.joystickMovable = document.createElement('div');
      }
        //computing css changes
      makeJoystick(){
        this.htmlElement.style.width = this.radius*2+"px";
        this.htmlElement.style.height = this.radius*2+"px";
        this.htmlElement.style.backgroundColor = "red";
      }
      makeJoystickMovable() {
        this.joystickMovable.style.width = INITIALRADIUS*2+"px";
        this.joystickMovable.style.height = INITIALRADIUS*2+"px";
        this.joystickMovable.style.backgroundColor = "red";
        this.joystickMovable.style.position = "fixed";
        this.joystickMovable.style.borderRadius = "100%";
      }
      changeRadius(int){
        this.htmlElement.style.margin = parseInt(window.getComputedStyle(this.htmlElement).margin, 10) - (int-this.radius) + "px";
        this.radius = int;
      }
        //computing changes to variables
      updatePos(e){
        //pos
        if(e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel'){
          this.posX = e.touches[0].clientX;
          this.posY = e.touches[0].clientY;
        } else if (e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover'|| e.type=='mouseout' || e.type=='mouseenter' || e.type=='mouseleave') {
          this.posX = e.clientX;
          this.posY = e.clientY;
        }
        let marginVal = parseInt(window.getComputedStyle(this.htmlElement).margin, 10);
        this.posY = window.innerHeight - this.posY - this.radius - marginVal;
        this.posX -= marginVal + this.radius;
        //speed
        this.spd = Math.sqrt((this.posX*this.posX) + (this.posY*this.posY)) / this.radius;
        this.checkIfWithinRadius();
          //finalize spd
          this.spd = Math.round(this.spd*100)/100;
        //angle
        this.angl = Math.atan(this.posY/this.posX);
        /*if((Math.PI/4)>this.angl && this.angl>(-Math.PI/4)){this.angl = 0;}
        else if(this.angl<0){ this.angl = -Math.PI/2;}
          else {this.angl = Math.PI/2;}*///use 4 cardinal directions

        this.angl = (this.posX<0) ? (Math.PI+this.angl) : ((this.posY<0)?(2*Math.PI)+this.angl:this.angl);
          //convert to degrees if u want
        //this.angl *= (180)/Math.PI;
        this.translateStats();
      }
      checkIfWithinRadius(){
        if(this.spd>1){
          this.posX /= this.spd; this.posY /= this.spd;
          this.spd = 1;
        }
      }
        //event functions
      startJoystick(event) {
        //make movable part of joystick in html
        this.makeJoystickMovable();
        this.htmlElement.appendChild(this.joystickMovable);
        //start the joystick
        this.joystickClicked = true;
          this.changeRadius(85);
        this.makeJoystick();
        this.htmlElement.style.backgroundColor = "lightgreen";
        //update
        this.moveJoystick(event);
        
        //pause button shenanigans
        pauseBtn.htmlElement.addEventListener('touchstart', pauseBtn.specialPauseFunction);
      }
      stopJoystick() {
        //delete movable part of joystick in html
        this.htmlElement.innerText = "";
        //stop the joystick
        this.joystickClicked = false;
        this.changeRadius(60);
        this.makeJoystick();
        this.htmlElement.style.backgroundColor = "red";
        //reset stats
        this.resetStats();
        this.displayStats();
        this.translateStats();

        //pause button shenanigans
        try{pauseBtn.htmlElement.removeEventListener('touchstart', pauseBtn.specialPauseFunction);}
        catch(err){}
      }
      moveJoystick(event) {
        if (this.joystickClicked){
          //update position
          this.updatePos(event);
          this.displayStats();
          //move joystickMovable
          this.moveJoystickMovable();
        }
      }
        //moving joystick movable
      moveJoystickMovable(){
        var marginVal = parseInt(window.getComputedStyle(this.htmlElement).margin, 10);
        this.joystickMovable.style.left = marginVal + this.radius - INITIALRADIUS + this.posX + "px";
        this.joystickMovable.style.bottom = marginVal + this.radius - INITIALRADIUS + this.posY + "px";
      }
        //display functions
      displayStats(){
        let uno = "Ek ", dos = "Wi ", tre = "Spe ", qua = "Ang ";
        let x = document.getElementById('x_coordinate');
        let y = document.getElementById('y_coordinate');
        let s = document.getElementById('speed');
        let a = document.getElementById('angle');
        x.innerText = Math.floor(this.posX);
        y.innerText = Math.floor(this.posY);
        s.innerText = this.spd;
        a.innerText = Math.floor(this.angl*100)/100;
        document.getElementById('e1').innerText=" "+uno.substring(x.innerText.length,4);
        document.getElementById('e2').innerText=" "+dos.substring(y.innerText.length,4);
        document.getElementById('e3').innerText=" "+tre.substring(s.innerText.length,5);
        document.getElementById('e4').innerText=" "+qua.substring(a.innerText.length,5);
      }
      resetStats(){
        this.posX=0; this.posY=0; this.spd=0;
      }
      translateStats(){
        player.speed = 8*this.spd; player.moveAngle = this.angl;
      }
    }
  </script>

</html>